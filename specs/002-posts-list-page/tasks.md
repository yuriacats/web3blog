# タスク: ブログ記事一覧ページ

**入力**: `/specs/002-posts-list-page/` の設計ドキュメント
**前提条件**: plan.md, spec.md, research.md, data-model.md, contracts/, quickstart.md

**テスト**: spec.md で明示的なテストタスクは要求されていません。バックエンドリポジトリ関数は開発中に手動でテストされます。正式な Jest テストはオプションの拡張です。

**構成**: タスクはユーザーストーリー（US1: 記事を閲覧、US2: 空の状態）ごとにグループ化され、独立した実装とテストを可能にします。

## フォーマット: `[ID] [P?] [Story] 説明`

- **[P]**: 並列実行可能（異なるファイル、依存関係なし）
- **[Story]**: このタスクが属するユーザーストーリー（US1, US2）
- 説明には正確なファイルパスを含める

## パス規約

- **モノレポ構造**: リポジトリルートに `backend/src/`、`front/src/app/`
- **バックエンド**: `backend/src/` の TypeScript ファイル
- **フロントエンド**: `front/src/app/` の Next.js App Router ページ

---

## Phase 1: セットアップ（検証 & 準備）

**目的**: 既存のインフラストラクチャの準備ができているか確認し、実装の準備をする

- [ ] T001 データベース接続とスキーマを確認: `docker-compose up -d db && docker-compose exec db mysql -u backend -ptoor -e "USE webblog; SHOW TABLES;"` を実行
- [ ] T002 テストデータの存在を確認: `docker-compose exec db mysql -u backend -ptoor -e "USE webblog; SELECT COUNT(*) FROM post;"` を実行
- [ ] T003 [P] バックエンドビルドを確認: `cd backend && pnpm run build` を実行
- [ ] T004 [P] フロントエンドビルドを確認: `cd front && pnpm run build` を実行
- [ ] T005 tRPC インフラストラクチャを確認: `backend/src/index.ts` が `appRouter` をエクスポートし、`frontend` が型をインポートできることを確認

**チェックポイント**: すべてのインフラストラクチャが確認済み - 実装の準備完了

---

## Phase 2: 基盤（型定義 & データベースアクセス）

**目的**: すべてのユーザーストーリーが依存する中核的な型定義とデータベースユーティリティ

**⚠️ 重要**: これらはユーザーストーリーの実装を開始する前に完了する必要があります

- [ ] T006 [P] `backend/src/interface.ts` に Tag 型を追加: Zod を使用して `TagSchema` と `Tag` 型を定義
- [ ] T007 [P] `backend/src/interface.ts` に PostListItem 型を追加: slug, title, tags[], createDate を持つ `PostListItemSchema` と `PostListItem` 型を定義
- [ ] T008 データベース接続ヘルパーが存在しない場合は作成: `backend/src/repository.ts` が `connection()` 関数をエクスポートすることを確認（既に存在）

**チェックポイント**: 型定義の準備完了 - ユーザーストーリーを実装可能

---

## Phase 3: ユーザーストーリー 1 - 最新のブログ記事を閲覧（優先度: P1）🎯 MVP

**目標**: タイトル、クリック可能なリンク、タグを含むすべての公開ブログ記事の一覧を新しい順に表示

**独立したテスト**: `http://localhost:3000/posts` にアクセスし、タイトル（クリック可能）、タグを含む記事一覧が表示され、最新の記事が最初に表示されることを確認。記事タイトルをクリックして `/posts/[slug]` にナビゲートすることを確認。

**受け入れ基準**（spec.md より）:
- ✅ タイトルとクリック可能なリンクを含む記事一覧が表示される
- ✅ 各記事にタグが表示される
- ✅ 記事が新しい順に並んでいる
- ✅ リンクが正しい詳細ページにナビゲートする

### ユーザーストーリー 1 の実装

#### バックエンド: データベースリポジトリ

- [ ] T009 [US1] `backend/src/repositories/post.ts` に `fetchAllPosts()` を実装: 2クエリパターン（記事クエリ + タグクエリ）を実行し `PostListItem[]` を返す関数を作成
- [ ] T010 [US1] `fetchAllPosts()` に記事クエリを追加: SELECT post.id, post.slug, post.create_date, post_revision.title FROM post JOIN (最新の公開リビジョンのサブクエリ) ORDER BY create_date DESC
- [ ] T011 [US1] `fetchAllPosts()` にタグクエリを追加: SELECT tag_post.post_id, tag_name.id, tag_name.name FROM tag_post JOIN tag_name WHERE post_id IN (...)
- [ ] T012 [US1] `fetchAllPosts()` にデータマージロジックを実装: 記事とタグを適切な Zod 検証で `PostListItem[]` に結合

#### バックエンド: tRPC エンドポイント

- [ ] T013 [US1] `backend/src/index.ts` に `postsList` エンドポイントを追加: `fetchAllPosts()` を呼び出し `Promise<PostListItem[]>` を返す `t.procedure.query()` を定義
- [ ] T014 [US1] tRPC エンドポイント型エクスポートを確認: `AppRouter` 型がフロントエンドの型安全性のために `postsList` を含むことを確認

#### フロントエンド: 記事一覧ページ

- [ ] T015 [US1] `front/src/app/posts/page.tsx` の 501 スタブを置き換え: `trpc.postsList.query()` を呼び出す Server Component を作成
- [ ] T016 [US1] 記事一覧のレンダリングを実装: `posts` 配列をマップし、各記事を `<Link href={/posts/${post.slug}}>{post.title}</Link>` でレンダリング
- [ ] T017 [US1] タグのレンダリングを実装: 各記事の `post.tags` をマップしてタグ名を表示（例: `<span>{tag.name}</span>`）
- [ ] T018 [US1] 基本的なスタイリングを追加: 読みやすさのための最小限の CSS を適用（リストフォーマット、リンクスタイリング、タグ表示）

#### 検証

- [ ] T019 [US1] 手動テスト: `docker-compose up` を起動し、`http://localhost:3000/posts` にアクセスして記事が正しく表示されることを確認
- [ ] T020 [US1] クリック可能なリンクをテスト: 記事タイトルをクリックし、`/posts/[slug]` へのナビゲーションが動作することを確認
- [ ] T021 [US1] タグ表示をテスト: 各記事のすべてのタグが表示されることを確認
- [ ] T022 [US1] 並び順をテスト: 記事が新しい順に並んでいることを確認（`create_date` をチェック）

**チェックポイント**: ユーザーストーリー 1 完了 - MVP 機能（ブログ記事が閲覧可能）

---

## Phase 4: ユーザーストーリー 2 - 空の状態を適切に処理（優先度: P2）

**目標**: 記事が利用できない場合、空白や混乱するページではなく、明確なメッセージを表示

**独立したテスト**: 一時的にデータベースをクリアするか、すべての記事を `public=0` に設定し、`/posts` にアクセスして、フレンドリーな「記事がありません」メッセージが表示されることを確認。

**受け入れ基準**（spec.md より）:
- ✅ 記事が存在しない場合に空の状態メッセージが表示される
- ✅ 公開記事のみが表示される（下書きは除外）

### ユーザーストーリー 2 の実装

- [ ] T023 [US2] `front/src/app/posts/page.tsx` に空の状態チェックを追加: リストをレンダリングする前に `if (posts.length === 0)` 条件を追加
- [ ] T024 [US2] 空の状態 UI を実装: 「まだ記事がありません。またお越しください！」のようなメッセージを含む JSX を返す
- [ ] T025 [US2] 空の状態の基本的なスタイリングを追加: 中央揃えレイアウトと適切なタイポグラフィを適用

#### 検証

- [ ] T026 [US2] 空の状態をテスト: `docker-compose exec db mysql -u backend -ptoor -e "USE webblog; UPDATE post_revision SET public=0;"` を実行してから `/posts` を再読み込み
- [ ] T027 [US2] 空のメッセージ表示を確認: フレンドリーなメッセージが表示されることを確認（空白ページやエラーではない）
- [ ] T028 [US2] テストデータを復元: `docker-compose exec db mysql -u backend -ptoor webblog < db/10_testData.sql` を実行して記事を復元

**チェックポイント**: ユーザーストーリー 2 完了 - 適切な空の状態処理

---

## Phase 5: 仕上げ & 最終検証

**目的**: 最終統合テスト、コード品質、ドキュメント

- [ ] T029 [P] バックエンドで TypeScript コンパイラを実行: `cd backend && npx tsc --noEmit`（ゼロエラーを確認）
- [ ] T030 [P] フロントエンドで TypeScript コンパイラを実行: `cd front && npx tsc --noEmit`（ゼロエラーを確認）
- [ ] T031 [P] バックエンドで ESLint を実行: `cd backend && pnpm run lint`（ゼロエラーを確認）
- [ ] T032 [P] フロントエンドで ESLint を実行: `cd front && pnpm run lint`（ゼロエラーを確認）
- [ ] T033 完全な統合テストを実行: `docker-compose up` を起動し、すべてのサービスがエラーなしで起動することを確認
- [ ] T034 手動機能テストを実行: 完全なユーザージャーニーを実行 - 記事一覧を表示、リンクをクリック、タグを確認、空の状態をテスト
- [ ] T035 パフォーマンス目標を確認: `/posts` のページ読み込み時間を測定（2秒未満であるべき）
- [ ] T036 エッジケースを確認: タグのない記事をテスト（空の配列を確認）、長いタイトル（必要に応じて切り捨てを確認）、データベース失敗（エラー処理を確認）
- [ ] T037 必要に応じてドキュメントを更新: 新しい記事一覧ページに関する関連ノートを `quickstart.md` または README に追加
- [ ] T038 変更をコミット: `git add -A && git commit -m "記事一覧ページを実装 (Issue #16)"`

**チェックポイント**: 機能が完成し検証済み

---

## 依存関係 & 実行順序

### フェーズ依存関係

- **セットアップ（Phase 1）**: 依存関係なし - すぐに開始可能
- **基盤（Phase 2）**: セットアップに依存 - すべてのユーザーストーリーをブロック
- **ユーザーストーリー 1（Phase 3）**: 基盤に依存 - コア機能（MVP）
- **ユーザーストーリー 2（Phase 4）**: ユーザーストーリー 1 に依存（同じコンポーネントを使用、空の状態チェックを追加）
- **仕上げ（Phase 5）**: すべてのユーザーストーリーの完了に依存

### ユーザーストーリー依存関係

- **ユーザーストーリー 1（P1 - 記事を閲覧）**: 独立 - 基盤の後に開始可能
- **ユーザーストーリー 2（P2 - 空の状態）**: US1 に依存（同じページコンポーネントを変更）

### 各ユーザーストーリー内

**US1（記事を閲覧）**:
- バックエンドタスク（T009-T014）: 基盤完了後に並列実行可能
- フロントエンドタスク（T015-T018）: バックエンド tRPC エンドポイント（T013 完了）を待つ必要あり
- 検証（T019-T022）: 実装完了後に順次実行

**US2（空の状態）**:
- 実装（T023-T025）: US1 完了を待つ必要あり（同じコンポーネントを変更）
- 検証（T026-T028）: T025 後に順次実行

### 並列実行の機会

**セットアップ（Phase 1）**:
- T003-T004: バックエンドとフロントエンドのビルド（並列）

**基盤（Phase 2）**:
- T006-T007: 型定義（並列 - 異なる型）

**US1 バックエンド**:
- T009-T012: リポジトリ実装（順次 - T012 は T009-T011 に依存）
- T013-T014: tRPC エンドポイント（順次 - T014 は T013 に依存）

**US1 フロントエンド**:
- T015-T018: ページ実装（順次 - 同じファイルに構築）

**仕上げ（Phase 5）**:
- T029-T032: リンティングと型チェック（4つの並列タスク）

---

## 実装戦略

### MVP ファースト（ユーザーストーリー 1 のみ - 記事を閲覧）

1. **Phase 1 完了: セットアップ**（T001-T005）- インフラストラクチャを確認
2. **Phase 2 完了: 基盤**（T006-T008）- 型定義
3. **Phase 3 完了: ユーザーストーリー 1**（T009-T022）- コア記事一覧機能
4. **停止して検証**:
   - 記事一覧が正しく表示される
   - リンクが動作する
   - タグが表示される
   - パフォーマンスが許容範囲
5. **準備ができたらデプロイ/デモ** - ブログが閲覧可能（MVP 達成）

### 段階的な提供

1. **基盤**（Phase 1-2）→ インフラストラクチャの準備完了
2. **ユーザーストーリー 1**（Phase 3）→ デプロイ/デモ（MVP - 閲覧可能なブログ）
3. **ユーザーストーリー 2**（Phase 4）→ デプロイ/デモ（適切な空の状態）
4. **仕上げ**（Phase 5）→ 最終品質ゲート合格

---

## 成功基準のマッピング

| 成功基準 | 検証方法 | タスク ID |
|---------|---------|---------|
| SC-001: ページ読み込み <2秒 | パフォーマンステスト | T035 |
| SC-002: 100% のリンクが正しくナビゲート | 手動リンクテスト | T020 |
| SC-003: すべてのタグが表示される | 手動タグ検査 | T021 |
| SC-004: 一貫した新しい順の並び | 手動並び順チェック | T022 |
| SC-005: 空/100以上の記事を処理 | エッジケーステスト | T036 |
| SC-006: 下書き記事が表示されない | データベースクエリ検証 | T002, T010 |

---

## 推定工数

| Phase | ユーザーストーリー | タスク数 | 推定時間 | 累積 |
|-------|----------------|---------|---------|------|
| 1: セットアップ | - | 5 | 10分 | 10分 |
| 2: 基盤 | - | 3 | 15分 | 25分 |
| 3: US1 バックエンド | 記事を閲覧 | 6 | 45分 | 70分 |
| 3: US1 フロントエンド | 記事を閲覧 | 4 | 30分 | 100分 |
| 3: US1 検証 | 記事を閲覧 | 4 | 15分 | 115分 |
| 4: US2 | 空の状態 | 6 | 20分 | 135分 |
| 5: 仕上げ | - | 10 | 25分 | 160分 |

**合計**: 38タスク、推定2.5時間

**推奨**: ユーザーストーリー間のチェックポイント検証を含む1セッションで実行。

---

## 注記

- **既存インフラストラクチャ**: tRPC、データベース接続、ルーティングは既に設定済み
- **最小スコープ**: 複雑なビジネスロジックのない単純な読み取り操作
- **手動テスト**: MVP には十分（Jest テストはオプションの拡張）
- **型安全性**: tRPC が自動的にフルスタック型安全性を提供
- **将来の拡張**: ページネーション（#32）、検索（#17）は別の Issue

---

**ステータス**: タスクは実装の準備ができています。Phase 1（セットアップ）から開始してください。
